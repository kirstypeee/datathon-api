'use strict';
var path = require("path");
var logger = require(path.join(__dirname, 'logger.js'))();
module.exports = function() {
  var metric = {
    latencyStats: {
      'count': 0,
      'sum': 0,
      'average': 0
    },
    httpStats: {
      'count': 0,
      'duration': 0,
      'average': 0
    },
    memoryStats: {
      'count': 0,
      'sum': 0,
      'average': 0
    },
    cpuStats: {
      'count': 0,
      'sum': 0,
      'average': 0
    },
    heapStats: {
      'count': 0,
      'usedSum': 0,
      'usedAverage': 0,
      'committed': 0,
      'maxHeap': 0,
      'heapSizeLimit': 0,
      'maxSemiSpace': 0,
      'maxOldSpace': 0
    },
    throughputStats: {
      'duration': 0,
      'lastCalculateTime': new Date().getTime(),
      'requestCount': 0,
      'throughput': 0
    }
  };
  metric.reset = function() {
    metric.latencyStats = {
      'count': 0,
      'sum': 0,
      'average': 0
    };
    metric.httpStats = {
      'count': 0,
      'duration': 0,
      'average': 0
    };
    metric.memoryStats = {
      'count': 0,
      'sum': 0,
      'average': 0
    };
    metric.cpuStats = {
      'count': 0,
      'sum': 0,
      'average': 0
    };
    metric.heapStats = {
      'count': 0,
      'usedSum': 0,
      'usedAverage': 0,
      'committed': metric.heapStats.committed,
      'maxHeap': metric.heapStats.maxHeap,
      'heapSizeLimit': metric.heapStats.heapSizeLimit,
      'maxSemiSpace': metric.heapStats.maxSemiSpace,
      'maxOldSpace': metric.heapStats.maxOldSpace
    };
    metric.throughputStats = {
      'duration': 0,
      'lastCalculateTime': new Date().getTime(),
      'requestCount': 0,
      'throughput': 0
    };
  }
  metric.initAppMemory = function(maxHeap, heapSizeLimit, maxSemiSpace, maxOldSpace) {
    metric.heapStats.maxHeap = parseInt(maxHeap) || 0;
    metric.heapStats.heapSizeLimit = parseInt(heapSizeLimit) || 0;
    metric.heapStats.maxSemiSpace = parseInt(maxSemiSpace) || 0;
    metric.heapStats.maxOldSpace = parseInt(maxOldSpace) || 0;
  }
  metric.updateLatency = function(latency) {

    if (!latency || !latency.latency || !latency.latency.avg) return;
    var avgLatency;
    if (avgLatency = parseInt(latency.latency.avg)) {
      metric.latencyStats.count++;
      metric.latencyStats.sum += avgLatency;
    }

  }

  metric.updateHttp = function(http) {
    if (!http || !http.duration) return;
    var tmpDuration = parseInt(http.duration);
    if (!isNaN(tmpDuration)) {
      metric.httpStats.count++;
      metric.throughputStats.requestCount++;
      metric.httpStats.duration += tmpDuration;
    }

  }

  metric.updateMemory = function(memory) {
    if (!memory || !memory.physical) return;
    var tmpMemory;
    if (tmpMemory = parseInt(memory.physical)) {
      metric.memoryStats.count++;
      metric.memoryStats.sum += tmpMemory;
    }
  }

  metric.updateCpu = function(cpu) {
    if (!cpu || !cpu.process) return;
    var tmpCpu;
    if (tmpCpu = parseFloat(cpu.process)) {
      metric.cpuStats.count++;
      metric.cpuStats.sum += tmpCpu * 100;
    }

  }

  metric.updateHeap = function(heap) {
    if (!heap || !heap.size || !heap.used) return;
    var tmpSize = parseInt(heap.size);
    var tmpUsed = parseInt(heap.used);
    if (tmpSize && tmpUsed) {
      metric.heapStats.committed = tmpSize;
      metric.heapStats.count++;
      metric.heapStats.usedSum += tmpUsed;
    }

  }
  metric.calculate = function() {
    var latencyStats = metric.latencyStats;
    var httpStats = metric.httpStats;
    var memoryStats = metric.memoryStats;
    var cpuStats = metric.cpuStats;
    var heapStats = metric.heapStats;
    var throughputStats = metric.throughputStats;

    logger.debug("calculating metrics: " + JSON.stringify(metric));

    latencyStats.average = (latencyStats.sum > 0 && latencyStats.count > 0) ? latencyStats.sum / latencyStats.count : 0;
    latencyStats.count = 0;
    latencyStats.sum = 0;

    httpStats.average = (httpStats.duration > 0 && httpStats.count > 0) ? (httpStats.duration / httpStats.count + latencyStats.average) : 0; //final response time = eventloop latency + http duration average
    httpStats.count = 0;
    httpStats.duration = 0;

    memoryStats.average = (memoryStats.sum > 0 && memoryStats.count > 0) ? (memoryStats.sum / memoryStats.count) : memoryStats.average;
    memoryStats.count = 0;
    memoryStats.sum = 0;

    cpuStats.average = (cpuStats.sum > 0 && cpuStats.count > 0) ? (cpuStats.sum / cpuStats.count) : cpuStats.average;
    cpuStats.count = 0;
    cpuStats.sum = 0;

    heapStats.usedAverage = (heapStats.usedSum > 0 && heapStats.count > 0) ? (heapStats.usedSum / heapStats.count) : heapStats.usedAverage;
    heapStats.count = 0;
    heapStats.usedSum = 0;
    if (throughputStats.requestCount > 0) {
      var curTime = new Date().getTime();
      var durationTmp = curTime - throughputStats.lastCalculateTime;
      throughputStats.throughput = throughputStats.requestCount / (durationTmp / 1000);
      throughputStats.lastCalculateTime = curTime;
      throughputStats.requestCount = 0;
      throughputStats.duration = durationTmp;
    } else {
      throughputStats.requestCount = 0;
      throughputStats.throughput = 0;
      throughputStats.duration = 0;
    }
    var result = {
      eventloopLatency: latencyStats.average,
      responseTime: httpStats.average,
      memory: memoryStats.average,
      cpu: cpuStats.average,
      heap: {
        used: heapStats.usedAverage,
        committed: heapStats.committed,
        max: heapStats.maxHeap
      },
      throughput: throughputStats.throughput
    };
    logger.debug("calculating result: " + JSON.stringify(result));
    return result;
  }
  return metric;
}
