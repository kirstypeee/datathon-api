'use strict';
// process.env.NODE_EXTRA_CA_CERTS = "../cacerts.pem";
var http = require("http");
var https = require("https");
var path = require("path");
var ca;
var utilObj = require(path.join(__dirname, 'util.js'))();
var logger = require(path.join(__dirname, 'logger.js'))();
var ca = [];
var caUtil = require(path.join(__dirname, 'caUtil.js'))();
var defaultCaPath = path.join(__dirname,'../cacerts.pem');
var defaultCas = utilObj.getCertificates(defaultCaPath);
var selfSignedCas = [];
var certPath = '/usr/local/share/ca-certificates';
selfSignedCas = utilObj.getCertificates(certPath);
if (!selfSignedCas || selfSignedCas.length === 0) {
  selfSignedCas = utilObj.getCertificates(process.env.AUTOSCALING_CERTIFICATE_PATH);
}
if (!selfSignedCas || selfSignedCas.length === 0) {
  ca = defaultCas;
}else{
  ca = defaultCas.concat(selfSignedCas);
}
module.exports = function(enabledMetricsObj) {
  var appmetrics = require('appmetrics');
  var calculator = require(path.join(__dirname, 'calculator.js'))();
  var serviceEnvObj = utilObj.getServiceEnv();
  var appEnv = utilObj.getApplicationEnv();
  var agentObj = {
    reportIntervalID: 0,
    refreshIntervalID: 0,
    reportInterval: 30000,
    refreshInterval: 60000,
    isAgentEnabled: true,
    enabledMetrics: new Set(enabledMetricsObj)
  };
  agentObj.start = function() {
    agentObj.startMonitor();
    agentObj.startReport(serviceEnvObj);
    agentObj.notifyStatus(serviceEnvObj);

  }
  agentObj.startMonitor = function() {
    var monitor = appmetrics.monitor();
    monitor.on('initialized', function(env) {
      env = monitor.getEnvironment();
      calculator.initAppMemory(env['max.heap.size'], env['heap.size.limit'], env['max.semi.space.size'], env['max.old.space.size'])
    });
    monitor.on('eventloop', function(latency) {
      // logger.info("eventloop " + JSON.stringify(latency) + "\n");
      logger.debug(" appmetrics--->eventloop: " + JSON.stringify(latency));
      calculator.updateLatency(latency);
    });
    monitor.on('http', function(httpObj) {
      // logger.info("http " + JSON.stringify(httpObj) + "\n");
      logger.debug(" appmetrics--->http: " + JSON.stringify(httpObj));
      calculator.updateHttp(httpObj);
    });
    monitor.on('memory', function(memory) {
      // logger.info("memory " + JSON.stringify(memory) + "\n");
      logger.debug(" appmetrics--->memory: " + JSON.stringify(memory));
      calculator.updateMemory(memory);
    });
    monitor.on('cpu', function(cpu) {
      // logger.info("cpu " + JSON.stringify(cpu) + "\n");
      logger.debug(" appmetrics--->cpu: " + JSON.stringify(cpu));
      calculator.updateCpu(cpu);
    });
    monitor.on('gc', function(gc) {
      // logger.info("gc " + JSON.stringify(gc) + "\n");
      logger.debug(" appmetrics--->gc: " + JSON.stringify(gc));
      calculator.updateHeap(gc);
    });
  }

  agentObj.startReport = function(serviceEnv) {
    if (!serviceEnv) {
      logger.error('Auto-SCaling service is not bound to the app!');
      return;
    }
    agentObj.reportIntervalID = setInterval(function() {

      if (agentObj.isAgentEnabled == false) {
        logger.info('Agent is disabled by server');
        return;
      }
      var avgMetricData = calculator.calculate();
      var metrics = agentObj.constructMetrics(appEnv, serviceEnv, avgMetricData, new Date().getTime());
      if (null == metrics) {
        return;
      }
      agentObj.sendMetrics(serviceEnv, metrics);
    }, agentObj.reportInterval);

    agentObj.refreshIntervalID = setInterval(function() {
      agentObj.refreshHeartBeat(serviceEnv);
    }, agentObj.refreshInterval);
  }

  agentObj.resetReportInterval = function(newReportInterval) {
    clearInterval(agentObj.reportIntervalID);
    clearInterval(agentObj.refreshIntervalID);
    agentObj.reportInterval = newReportInterval;
    agentObj.startReport(serviceEnvObj);
  }

  agentObj.shouldReport = function(metricType) {
    return agentObj.enabledMetrics.has(metricType);
  }

  agentObj.createMetricsObj = function(category, group, name, value, unit, desc, timestamp) {
    var obj = new Object();
    obj.category = category;
    obj.group = group;
    obj.name = name;
    obj.value = value;
    obj.unit = unit;
    obj.desc = desc;
    obj.timestamp = timestamp;
    return obj;
  }

  agentObj.constructMetrics = function(appEnv, serviceEnv, avgMetricData, timestamp) {
    if (!appEnv || !serviceEnv) {
      return null;
    }

    var metricCategory = 'nodejs';
    var metrics = new Array();
    var cpuObj = agentObj.createMetricsObj(metricCategory, 'ProcessCpuLoad', 'ProcessCpuLoad', avgMetricData.cpu * 100, '%%', '', timestamp);
    var memoryObj = agentObj.createMetricsObj(metricCategory, 'memory', 'memory', avgMetricData.memory, 'Bytes', '', timestamp);
    var initHeapObj = agentObj.createMetricsObj(metricCategory, 'HeapMemoryUsage', 'init', 0, 'Bytes', '', timestamp);
    var commitedHeapObj = agentObj.createMetricsObj(metricCategory, 'HeapMemoryUsage', 'used', avgMetricData.heap.used, 'Bytes', '', timestamp);
    var usedHeapObj = agentObj.createMetricsObj(metricCategory, 'HeapMemoryUsage', 'committed', avgMetricData.heap.committed, 'Bytes', '', timestamp);
    var maxHeapObj = agentObj.createMetricsObj(metricCategory, 'HeapMemoryUsage', 'max', avgMetricData.heap.max, 'Bytes', '', timestamp);
    var throughputObj = agentObj.createMetricsObj(metricCategory, 'Web', 'throughput', avgMetricData.throughput, '', '', timestamp);
    var responseTimeObj = agentObj.createMetricsObj(metricCategory, 'Web', 'responseTime', avgMetricData.responseTime, 'ms', '', timestamp);
    var eventLoopLatencyObj = agentObj.createMetricsObj(metricCategory, 'Web', 'eventloopLatency', avgMetricData.eventloopLatency, 'ms', '', timestamp);

    if (agentObj.shouldReport("CPU")) {
      metrics.push(cpuObj);
    }

    if (agentObj.shouldReport("Memory")) {
      metrics.push(memoryObj);
    }

    if (agentObj.shouldReport("NODEJSHeapMemory") || agentObj.shouldReport("HeapMemory")) {
      metrics.push(initHeapObj);
      metrics.push(commitedHeapObj);
      metrics.push(usedHeapObj);
      metrics.push(maxHeapObj);
    }

    if (agentObj.shouldReport("ResponseTime")) {
      metrics.push(responseTimeObj);
    }

    if (agentObj.shouldReport("EventLoopLatency")) {
      metrics.push(eventLoopLatencyObj);
    }

    if (agentObj.shouldReport("Throughput")) {
      metrics.push(throughputObj);
    }

    var obj = new Object();

    obj.appId = appEnv['application_id'];
    obj.appName = appEnv['application_name'];
    obj.appType = 'nodejs';
    obj.serviceId = serviceEnv['service_id'];
    obj.instanceIndex = appEnv['instance_index'];
    obj.instanceId = appEnv['instance_id'];
    obj.timestamp = timestamp;
    obj.metrics = metrics;
    return obj;

  }

  agentObj.refreshConfigration = function(configString) {
    if (!configString) {
      logger.error("configString is not found or empty");
      return;
    }
    var configObject;
    try {
      configObject = JSON.parse(configString);
    } catch (e) {
      logger.error("The following error indicated the connection between auto-scaling agent and its backend is unstable. Safe to ignore the error if it happened occasionally.")
      logger.error("Failed to parse server configuration:" + configString);
      logger.error("Error:" + e);
      return
    }
    // {"reportInterval":100,"metricsConfig":{"agent":["CPU","MEMORY"]}}
    if ("reportInterval" in configObject) {
      var tmpInterval = parseInt(configObject["reportInterval"], 10);
      if (isNaN(tmpInterval)) {
        logger.error("failed to refresh configuration, report interval is not an interger");
        return;
      }
      tmpInterval *= 1000; //reportInterval from server is in unit Second and here we need ms
      if (agentObj.reportInterval != tmpInterval) {
        logger.info("change report interval from " + agentObj.reportInterval + " to " + tmpInterval);
        agentObj.resetReportInterval(tmpInterval);
      }
    }
    if ("metricsConfig" in configObject) {
      var metricsConfig = configObject["metricsConfig"];
      if ("agent" in metricsConfig) {
        var agent_config = metricsConfig["agent"];
        if (agent_config.length > 0) {
          agentObj.isAgentEnabled = true;
          agentObj.enabledMetrics = new Set();
          for (var index in agent_config) {
            agentObj.enabledMetrics.add(agent_config[index]);
          }
        } else {
          logger.info("agent coniguration is empty in server configuration");
          agentObj.isAgentEnabled = false;
        }
      } else {
        logger.info("no agent coniguration in server configuration");
        agentObj.isAgentEnabled = false;
      }
    } else {
      logger.info("metricsConfig is not in config");
      agentObj.isAgentEnabled = false;
    }
  }
  agentObj.sendMetrics = function(serviceEnv, metricObj) {
    if (!serviceEnv) {
      logger.error("sendMetrics:serviceEnv is not found or empty")
      return;
    }
    if (!serviceEnv.agentUsername) {
      logger.error("sendMetrics:serviceEnv.agentUsername is not found or empty")
      return;
    }
    if (!serviceEnv.agentPassword) {
      logger.error("sendMetrics:serviceEnv.agentPassword is not found or empty")
      return;
    }
    if (!serviceEnv.url) {
      logger.error("sendMetrics:serviceEnv.url is not found or empty");
      return;
    }
    if (!metricObj) {
      logger.error("sendMetrics:metricObj is not found or empty");
      return;
    }
    var serviceUrl = serviceEnv.url;
    var hostPort = utilObj.parseUrlToHostPort(serviceUrl);
    var host = hostPort[0];
    var port = hostPort[1];
    var agentUserName = serviceEnv.agentUsername;
    var agentPassword = serviceEnv.agentPassword;
    var authorization = 'Basic ' + new Buffer(agentUserName + ':' + agentPassword).toString("base64");
    var jsonStr;
    try {
      jsonStr = JSON.stringify(metricObj);
    } catch (e) {
      logger.error("The following error indicated the connection between auto-scaling agent and its backend is unstable. Safe to ignore the error if it happened occasionally.")
      logger.error("failed to stringify metricObj");
      logger.error("error:" + e);
      return;
    }
    var headers = {
      'Content-Type': 'application/json',
      'Content-Length': jsonStr.length,
      'Authorization': authorization
    };
    var options = {
      host: host,
      port: port,
      path: '/services/agent/report',
      method: 'POST',
      headers: headers,
      ca: ca
    };

    var req = https.request(options, function(res) {
      res.setEncoding('utf-8');
      var responseString = '';
      res.on('data', function(data) {
        responseString += data;
      });
      res.on('end', function() {});
    });
    req.on('error', function(e) {
      // TODO: handle error.
      logger.error("The following error indicated the connection between auto-scaling agent and its backend is unstable. Safe to ignore the error if it happened occasionally.")
      logger.error('failed to send metrics');
      logger.error('error:' + e);
    });
    logger.debug("sending metrics: " + jsonStr);
    req.write(jsonStr);
    req.end();
  }

  agentObj.notifyStatus = function(serviceEnv) {
    if (!serviceEnv) {
      logger.error("notifyStatus:serviceEnv is not found or empty")
      return;
    }
    if (!serviceEnv.agentUsername) {
      logger.error("notifyStatus:serviceEnv.agentUsername is not found or empty")
      return;
    }
    if (!serviceEnv.agentPassword) {
      logger.error("notifyStatus:serviceEnv.agentPassword is not found or empty")
      return;
    }
    if (!serviceEnv.app_id) {
      logger.error("notifyStatus:serviceEnv.app_id is not found or empty");
      return;
    }
    var serviceUrl = serviceEnv.url;
    var hostPort = utilObj.parseUrlToHostPort(serviceUrl);
    var host = hostPort[0];
    var port = hostPort[1];
    var appId = serviceEnv['app_id'];
    var agentUserName = serviceEnv['agentUsername'];
    var agentPassword = serviceEnv['agentPassword'];
    var authorization = 'Basic ' + new Buffer(agentUserName + ':' + agentPassword).toString("base64");
    var headers = {
      'Authorization': authorization
    };
    var options = {
      host: host,
      path: '/services/agent/status/' + appId,
      method: 'PUT',
      headers: headers,
      ca: ca
    };

    var req = https.request(options, function(res) {
      res.setEncoding('utf-8');
      var responseString = '';
      res.on('data', function(data) {
        responseString += data;
      });
      res.on('end', function() {});
    });
    req.on('error', function(e) {
      // TODO: handle error.
      logger.error("The following error indicated the connection between auto-scaling agent and its backend is unstable. Safe to ignore the error if it happened occasionally.")
      logger.error('failed to notifyStatus');
      logger.error('error:' + e);
    });
    req.end();
  }
  agentObj.refreshHeartBeat = function(serviceEnv) {
    if (!serviceEnv) {
      logger.error("refreshHeartBeat:serviceEnv is not found or empty")
      return;
    }
    if (!serviceEnv.agentUsername) {
      logger.error("refreshHeartBeat:serviceEnv.agentUsername is not found or empty")
      return;
    }
    if (!serviceEnv.agentPassword) {
      logger.error("refreshHeartBeat:serviceEnv.agentPassword is not found or empty")
      return;
    }
    if (!serviceEnv.app_id) {
      logger.error("refreshHeartBeat:serviceEnv.app_id is not found or empty");
      return;
    }
    if (!serviceEnv.service_id) {
      logger.error("refreshHeartBeat:serviceEnv.service_id is not found or empty");
      return;
    }
    var serviceUrl = serviceEnv.url;
    var hostPort = utilObj.parseUrlToHostPort(serviceUrl);
    var host = hostPort[0];
    var port = hostPort[1];
    var appId = serviceEnv['app_id'];
    var serviceId = serviceEnv['service_id'];
    var agentUserName = serviceEnv['agentUsername'];
    var agentPassword = serviceEnv['agentPassword'];
    var authorization = 'Basic ' + new Buffer(agentUserName + ':' + agentPassword).toString("base64");
    var headers = {
      'Content-Type': 'application/json',
      'Authorization': authorization
    };
    var options = {
      host: host,
      path: '/v1/agent/config/' + serviceId + '/' + appId + '?appType=nodejs',
      method: 'GET',
      headers: headers,
      ca: ca
    };
    var req = https.request(options, function(res) {
      res.setEncoding('utf-8');
      var responseString = '';
      res.on('data', function(data) {
        responseString += data;
      });
      res.on('end', function() {
        agentObj.refreshConfigration(responseString);
      });
    });
    req.on('error', function(e) {
      // TODO: handle error.
      logger.error("The following error indicated the connection between auto-scaling agent and its backend is unstable. Safe to ignore the error if it happened occasionally.")
      logger.error('failed to refreshHeartBeat');
      logger.error('error:' + e);
    });
    req.end();
  }
  return agentObj;
}
